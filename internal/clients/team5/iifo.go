package team5

import (
	"math"

	"github.com/SOMAS2020/SOMAS2020/internal/common/shared"
)

// PastDisastersList is a List of previous disasters.
type disasterInfo struct {
	epiX shared.Coordinate // x co-ord of disaster epicentre
	epiY shared.Coordinate // y ""
	mag  shared.Magnitude
	turn uint
}

type disasterHistory map[uint]disasterInfo // stores history of past disasters

// MakeDisasterPrediction is called on each client for them to make a prediction about a disaster
// Prediction includes location, magnitude, confidence etc
// COMPULSORY, you need to implement this method
func (c *client) MakeDisasterPrediction() shared.DisasterPredictionInfo {

	meanDisaster := c.getMeanDisasterInfo()
	prediction := shared.DisasterPrediction{
		CoordinateX: meanDisaster.epiX,
		CoordinateY: meanDisaster.epiY,
		Magnitude:   meanDisaster.mag,
		TimeLeft:    int(meanDisaster.turn),
	}

	prediction.Confidence = c.determineForecastConfidence()
	trustedIslandIDs := []shared.ClientID{}
	trustThresh := c.config.forecastTrustTreshold
	for id := range c.getTrustedTeams(trustThresh, false) {
		trustedIslandIDs = append(trustedIslandIDs, id)
	}

	// Return all prediction info and store our own island's prediction in global variable
	predictionInfo := shared.DisasterPredictionInfo{
		PredictionMade: prediction,
		TeamsOfferedTo: trustedIslandIDs,
	}
	return predictionInfo
}

// averages observations over history to get 'mean' disaster
func (c *client) getMeanDisasterInfo() disasterInfo {
	sumX, sumY, sumMag := 0.0, 0.0, 0.0

	for _, dInfo := range c.disasterHistory {
		sumX += dInfo.epiX
		sumY += dInfo.epiY
		sumMag += dInfo.mag
	}
	n := float64(len(c.disasterHistory))
	meanDisaster := disasterInfo{
		epiX: sumX / n,
		epiY: sumY / n,
		mag:  sumMag / n,
		turn: uint(n), // not really relevant for this
	}
	return meanDisaster
}

func (c *client) determineForecastConfidence() float64 {
	totalDisaster := disasterInfo{}
	sqDiff := func(x, meanX float64) float64 { return math.Pow(x-meanX, 2) }
	meanInfo := c.getMeanDisasterInfo()
	// Find the sum of the square of the difference between the actual and mean, for each field
	for _, d := range c.disasterHistory {
		totalDisaster.epiX += sqDiff(d.epiX, meanInfo.epiX)
		totalDisaster.epiY += sqDiff(d.epiY, meanInfo.epiY)
		totalDisaster.mag += sqDiff(d.mag, meanInfo.mag)
	}

	// TODO: find a better method of calculating confidence
	// Find the sum of the variances and the average variance
	variance := (totalDisaster.epiX + totalDisaster.epiY + totalDisaster.mag) / float64(len(c.disasterHistory))
	variance = math.Min(c.config.maxForecastVariance, variance)

	return c.config.maxForecastVariance - variance
}

// ReceiveDisasterPredictions provides each client with the prediction info, in addition to the source island,
// that they have been granted access to see
// COMPULSORY, you need to implement this method
func (c *client) ReceiveDisasterPredictions(receivedPredictions shared.ReceivedDisasterPredictionsDict) {
	// If we assume that we trust each island equally (including ourselves), then take the final prediction
	// of disaster as being the weighted mean of predictions according to confidence
	numberOfPredictions := float64(len(receivedPredictions) + 1)
	selfConfidence := c.predictionInfo.PredictionMade.Confidence

	// Initialise running totals using our own island's predictions
	totalCoordinateX := selfConfidence * c.predictionInfo.PredictionMade.CoordinateX
	totalCoordinateY := selfConfidence * c.predictionInfo.PredictionMade.CoordinateY
	totalMagnitude := selfConfidence * c.predictionInfo.PredictionMade.Magnitude
	totalTimeLeft := int(math.Round(selfConfidence)) * c.predictionInfo.PredictionMade.TimeLeft
	totalConfidence := selfConfidence

	// Add other island's predictions using their confidence values
	for _, prediction := range receivedPredictions {
		totalCoordinateX += prediction.PredictionMade.Confidence * prediction.PredictionMade.CoordinateX
		totalCoordinateY += prediction.PredictionMade.Confidence * prediction.PredictionMade.CoordinateY
		totalMagnitude += prediction.PredictionMade.Confidence * prediction.PredictionMade.Magnitude
		totalTimeLeft += int(math.Round(prediction.PredictionMade.Confidence)) * prediction.PredictionMade.TimeLeft
		totalConfidence += prediction.PredictionMade.Confidence
	}

	// Finally get the final prediction generated by considering predictions from all islands that we have available
	// This result is currently unused but would be used in decision making in full implementation
	finalPrediction := shared.DisasterPrediction{
		CoordinateX: totalCoordinateX / totalConfidence,
		CoordinateY: totalCoordinateY / totalConfidence,
		Magnitude:   totalMagnitude / totalConfidence,
		TimeLeft:    int((float64(totalTimeLeft) / totalConfidence) + 0.5),
		Confidence:  totalConfidence / numberOfPredictions,
	}

	c.Logf("Final Prediction: [%v]", finalPrediction)
}
